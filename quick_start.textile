---
layout: default
title: Quick Start
---

On this page you'll find everything you need to install and use Rbjs. Knowledge of Rails and Javascript is assumed.

p(note). Although this gem is incompatible with _prototype-rails_, it is not a drop-in replacement for it.

h2(#installation). Installation

Add the line

{% highlight sh %}
$ gem 'rbjs'
{% endhighlight %}

to your Gemfile and run

{% highlight sh %}
$ bundle install
{% endhighlight %}

h2(#usage). Usage

Similar to prototype-rails, there are two ways to write remote javascript: Directly inside the controller using the _render_ method, or inside an _.rbjs_ template. The second way is cleaner, since it keeps your view code outside of the controller, while the first way is much more pragmatic for simple and small snippets.

p(tip). The main idea behind Rbjs is to write ruby code the same way you would write javascript code and to keep the logic outside of the browser. Inside of Rbjs, all method calls and their arguments directly translate into javascript. This is true for any method and argument. Including arrays, hashes, rendered partials, ruby blocks and lambdas, and anything that has a _to_json_ or a _to_s_ method.


h3. Using the render method

Inside of your controller, in an action that is accessed via xhr, you can call _render :js_ with a block containing Rbjs code:

{% highlight ruby %}
render :js do
  console.log "Hello from ruby"
end
{% endhighlight %}

h3. Using .rbjs templates

_.rbjs_ templates are files inside your view directories that end with _.js.rbjs_. Whenever your application receives an xhr request, it will look for the corresponding _.rbjs_ template inside your view path. Let's say there is the following file called _greet_me.js.rbjs_ inside your _views/greeter/_ directory:

{% highlight ruby %}
console.log "Hello from ruby"
{% endhighlight %}

This file will be rendered and translated to javascript whenever your application receives an xhr request for "greeter#greet_me", for example by clicking a link that has been generated with _link_to "Greet me", "/greeter/greet_me", :remote => true_

h2. From Ruby to Javascript

To get a better understanding for how this translation works, take a look at the following examples.

h3. Working with methods

Simple method calls translate just as you would expect:

p(example). Simple methods

{% highlight ruby %}
# Result:
# window.alert("Hello world!");
window.alert "Hello world!"
{% endhighlight %}

This can be used to quickly update a DOM element in the browser via a controller action:

p(example). Update the DOM

{% highlight ruby %}
# Result:
# jQuery("#message_123").html("Hi guys!");
message = Message.find 123
render :js do
  jQuery(message.selector).html message.text
end
{% endhighlight %}

Since assignments are methods too, you can expect them to work as well:

p(example). Assignments

{% highlight ruby %}
# Result:
# myApp.currentUserName=("Conan O'Brien");
myApp.currentUserName = current_user.name
{% endhighlight %}

And because we work with ruby, array and hash access are also methods. This lets us use them inside of Rbjs, too:

p(example). Member access

{% highlight ruby %}
# Result:
# myApp.config["user name"]=(userData[12345]);
myApp.config["user name"]= userData[@user_id]
{% endhighlight %}

p(tip). You can access instance variables, view helper methods, and the local scope inside of Rbjs. As you can see, the calls to _current_user_, _message_, and _@user_id_ is not translated to javascript.

To call a javascript method without an argument, add a _!_ to its name.

p(example). Method without arguments

{% highlight ruby %}
# Result:
# myMethod;
# myMethod();
myMethod
myMethod!
{% endhighlight %}


h3. Working with arguments

As you have seen in the above examples, any arguments that get passed to javascript functions are being translated too. But this does not only work for simple arguments, like strings and numbers. You can work with any kind of object.

p(example). Primitive types

{% highlight ruby %}
# Result:
# foo("a string", 123, "a_symbol");
foo 'a string', 123, :a_symbol
{% endhighlight %}

Symbols are being converted to strings, while there is no change on strings and numbers. With this, we can use Rbjs to easily update rendered partials:

p(example). Partials

{% highlight ruby %}
# Result:
# jQuery("#posts").append("<div.../div>");
jQuery("#posts").append render @post
{% endhighlight %}

Arrays and Hashes, arbitrarily nested, are converted to javascript objects.

p(example). Arrays and Hashes

{% highlight ruby %}
# Result:
# foo(["Steven", {"street_name_": "Sesame Street", "street_number": 42}]);
foo [@user.name, {:street_name => @user.street_name, :street_number => @user.street_number}]
{% endhighlight %}

p(tip). Whenever you pass an argument to a javascript method, Rbjs will invoke it's _to_json_ method.

You can also pass nested Rbjs as arguments. This functionality, too, can be arbitrarily nested.

p(example). Nested Rbjs

{% highlight ruby %}
# Result:
# foo(bar(4).baz("hello"));
foo bar(4).baz "hello"
{% endhighlight %}

h3. The local scope

Caution must be used when working with local ruby variables to not get confused. The following Rbjs example will not render what you expect.

{% highlight ruby %}
# Result:
# foo(1234);
myVar = foo 1234
{% endhighlight %}

This is not an assignment to a javascript variable, but to a normal local ruby variable. To assign a local javascript variable, you need to assign it to _self_, like so:

p(example). Local assignment

{% highlight ruby %}
# Result:
# myVar=(foo(1234));
local_var = foo 1234
self.myVar = local_var
{% endhighlight %}

You can use the _var_ method on _self_ to initialize new javascript variables:

p(example). Variable declaration

{% highlight ruby %}
# Result:
# var myVar=(foo(1234));
local_var = foo 1234
var.myVar = local_var
{% endhighlight %}

h3. Lambda and blocks

Passing blocks or lambdas to methods will convert them to anonymous javascript functions.

p(example). Blocks

{% highlight ruby %}
# Result:
# jQuery(".message").each(function(index, element) {
#   console.log(index.toString() + " is " + element);
# })
jQuery('.message').each do |index, element|
  console.log index.toString! + " is " + element
end
{% endhighlight %}

p(note). You need to be careful when using operators as seen in this example on javascript elements, eg. for string concatenation. You can read more about using operators down below.

Similarly, you can let Rbjs convert lambdas to functions:

p(example). Lambdas

{% highlight ruby %}
# Result:
# setTimeout(function(){alert("One second");}, 1000);
func = lambda { alert "One second" }
setTimeout func, 1000
{% endhighlight %}

h3. Raw javascript

You can render raw javascript to the page using the _<<_ method:

{% highlight ruby %}
self << "alert('hello');"
{% endhighlight %}

h3. Avoiding name conflicts

Let's say you have an object living in the global namespace of your client-side javascript called _Rails_. The following Rbjs would raise an exception:

{% highlight ruby %}
# Raises:
# NoMethodError: undefined method `foo' for Rails:Module
Rails.foo!
{% endhighlight %}

To resolve this conflict, you'd have to prefix the occupied identifier with _self._, like so:

{% highlight ruby %}
# Result:
# Rails.foo();
self.Rails.foo!
{% endhighlight %}

h3. Operators

Yes, you can use operators on Rbjs objects. However, you need to be very careful when combining Rbjs objects with other ruby objects. Take a look at the following example:

p(example). Operators

{% highlight ruby %}
# Result:
# alert(something + ", truly!");
alert something + ", truly!"
{% endhighlight %}

These kinds of operations work if and only if the first object in the chain of operations is an Rbjs call (in this case _"something"_). The following example does not work:

{% highlight ruby %}
# Raises:
# TypeError: can't convert Rbjs::Expression to String
alert "Truly " + something
{% endhighlight %}

When you want to work with operators inside of Rbjs you should always think about them as method calls and make sure that they are only called on Rbjs objects.

p(tip). This limitation is addressed with the release of ruby 2.0 and refinements. For now, you can use the following workaround:
{% highlight ruby %}
# Result:
# console.log("Hello, "+user);
console.log Rbjs::Expression.new('"Hello, "') + user
{% endhighlight %}


h3. Even more

Check back soon.